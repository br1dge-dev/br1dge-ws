<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>br1dge.xyz</title>
    <style>
      * { 
        margin: 0; 
        padding: 0; 
        box-sizing: border-box; 
        cursor: none;
      }
      
      html, body {
        height: 100%;
        width: 100%;
        overflow: hidden;
        background: #000;
      }

      #canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      let width, height;
      let mouseX = 0, mouseY = 0;
      let targetX = 0, targetY = 0;
      let logoHovered = false;
      let clickRipples = [];
      let pulsePhase = 0;
      
      const gridSize = 80;
      const bits = [];
      
      // Resize
      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        initBits();
      }
      
      // Initialize bits along grid
      function initBits() {
        bits.length = 0;
        
        // Horizontal bits
        for (let y = gridSize; y < height; y += gridSize) {
          for (let i = 0; i < 5; i++) {
            bits.push({
              x: Math.random() * width,
              y: y,
              speed: 0.3 + Math.random() * 0.5,
              axis: 'h',
              baseY: y
            });
          }
        }
        
        // Vertical bits
        for (let x = gridSize; x < width; x += gridSize) {
          for (let i = 0; i < 5; i++) {
            bits.push({
              x: x,
              y: Math.random() * height,
              speed: 0.3 + Math.random() * 0.5,
              axis: 'v',
              baseX: x
            });
          }
        }
      }
      
      // Draw grid
      function drawGrid() {
        ctx.strokeStyle = '#151515';
        ctx.lineWidth = 1;
        
        for (let x = 0; x <= width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        
        for (let y = 0; y <= height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
      }
      
      // Draw animated bits
      function drawBits() {
        bits.forEach(bit => {
          if (bit.axis === 'h') {
            bit.x += bit.speed;
            if (bit.x > width) bit.x = 0;
          } else {
            bit.y += bit.speed;
            if (bit.y > height) bit.y = 0;
          }
          
          // Calculate fade based on position
          let fade;
          if (bit.axis === 'h') {
            fade = Math.sin((bit.x / width) * Math.PI) * 0.4;
          } else {
            fade = Math.sin((bit.y / height) * Math.PI) * 0.4;
          }
          
          ctx.beginPath();
          ctx.arc(bit.x, bit.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(0, 255, 255, ${fade})`;
          ctx.fill();
        });
      }
      
      // Draw logo - PERFECTLY CENTERED
      function drawLogo() {
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Logo size
        const size = Math.min(width, height) * 0.4;
        
        // Check hover
        const dx = mouseX - centerX;
        const dy = mouseY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        logoHovered = dist < size * 0.4;
        
        // Pulse effect
        pulsePhase += 0.02;
        const pulse = logoHovered ? 1 + Math.sin(pulsePhase * 3) * 0.03 : 1;
        
        // Color cycle
        const hue = (Date.now() / 50) % 360;
        const color = logoHovered 
          ? `hsl(${hue}, 100%, 70%)` 
          : '#E5E5E5';
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.scale(pulse, pulse);
        
        // Draw bridge symbol
        ctx.font = `bold ${size}px system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = color;
        ctx.fillText('Í†', 0, 0);
        
        ctx.restore();
      }
      
      // Draw cursor
      function drawCursor() {
        // Smooth follow
        targetX += (mouseX - targetX) * 0.15;
        targetY += (mouseY - targetY) * 0.15;
        
        const size = logoHovered ? 40 : 8;
        const alpha = logoHovered ? 0.3 : 0.8;
        
        // Outer ring when hovering
        if (logoHovered) {
          ctx.beginPath();
          ctx.arc(targetX, targetY, size, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        // Inner dot
        ctx.beginPath();
        ctx.arc(targetX, targetY, logoHovered ? 4 : 4, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }
      
      // Draw click ripples
      function drawRipples() {
        clickRipples = clickRipples.filter(r => {
          r.size += 15;
          r.alpha -= 0.05;
          
          if (r.alpha <= 0) return false;
          
          ctx.beginPath();
          ctx.arc(r.x, r.y, r.size, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(0, 255, 255, ${r.alpha})`;
          ctx.lineWidth = 2;
          ctx.stroke();
          
          return true;
        });
      }
      
      // Main loop
      function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        
        drawGrid();
        drawBits();
        drawLogo();
        drawRipples();
        drawCursor();
        
        requestAnimationFrame(draw);
      }
      
      // Events
      window.addEventListener('resize', resize);
      
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });
      
      document.addEventListener('click', (e) => {
        clickRipples.push({
          x: e.clientX,
          y: e.clientY,
          size: 10,
          alpha: 1
        });
        
        // Burst bits on click
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          bits.push({
            x: e.clientX,
            y: e.clientY,
            speed: 3 + Math.random() * 2,
            axis: Math.random() > 0.5 ? 'h' : 'v',
            baseX: e.clientX,
            baseY: e.clientY,
            vx: Math.cos(angle) * 3,
            vy: Math.sin(angle) * 3,
            life: 60
          });
        }
      });
      
      // Update bits with burst particles
      const originalDrawBits = drawBits;
      function drawBitsWithBurst() {
        bits.forEach((bit, index) => {
          if (bit.life !== undefined) {
            bit.x += bit.vx;
            bit.y += bit.vy;
            bit.life--;
            
            if (bit.life <= 0) {
              bits.splice(index, 1);
              return;
            }
            
            const fade = bit.life / 60;
            ctx.beginPath();
            ctx.arc(bit.x, bit.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 0, 255, ${fade})`;
            ctx.fill();
          } else {
            if (bit.axis === 'h') {
              bit.x += bit.speed;
              if (bit.x > width) bit.x = 0;
            } else {
              bit.y += bit.speed;
              if (bit.y > height) bit.y = 0;
            }
            
            let fade;
            if (bit.axis === 'h') {
              fade = Math.sin((bit.x / width) * Math.PI) * 0.3;
            } else {
              fade = Math.sin((bit.y / height) * Math.PI) * 0.3;
            }
            
            ctx.beginPath();
            ctx.arc(bit.x, bit.y, 2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 255, 255, ${fade})`;
            ctx.fill();
          }
        });
      }
      
      // Override
      drawBits = drawBitsWithBurst;
      
      // Start
      resize();
      draw();
    </script>
  </body>
</html>
