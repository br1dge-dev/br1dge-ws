<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>br1dge.xyz</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; cursor: none; }
      html, body { height: 100%; width: 100%; overflow: hidden; background: #000; }
      #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      let W, H, centerX, centerY;
      let mouseX = 0, mouseY = 0;
      let cursorX = 0, cursorY = 0;
      
      // Logo state
      let logoScale = 1;
      let logoTargetScale = 1;
      let logoBaseScale = 1; // Wächst permanent mit jedem Upgrade
      let logoGlow = 0;
      let upgradeLevel = 0; // Anzahl der Upgrades
      
      // Logo Energie-Ringe (akkumulierte Energie-Releases)
      const logoOutlines = [];
      
      // Cursor energy (von Partikeln gesammelt)
      let cursorEnergy = 0;
      const ENERGY_THRESHOLD = 0.2;
      const MAX_ENERGY = 1.0;
      
      // Red particle state
      let redParticleActive = false;
      let redParticleSpawnTime = 0;
      let redParticleCatches = 0; // Wie oft gefangen in dieser Ladung
      let isInverted = false;
      const redParticle = { x: 0, y: 0, vx: 0, vy: 0, active: false, phase: 0 };
      
      // Particles
      const particles = [];
      
      // Ripples
      const ripples = [];
      
      // Ambient floating particles
      const ambientParticles = [];
      
      function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        centerX = W / 2;
        centerY = H / 2;
      }
      
      // Distance from logo (Logo ist IMMER in der Mitte)
      function distFromLogo(x, y) {
        const dx = x - centerX;
        const dy = y - centerY;
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      // Modal für Level 10 - CLEAN, MINIMAL, STRIKING
      let modalShown = false;
      function showModal() {
        if (modalShown) return;
        modalShown = true;
        
        // Inversion zurücksetzen für Modal
        canvas.style.filter = '';
        isInverted = false;
        
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed; top: 0; left: 0; width: 100%; height: 100%;
          background: #000; color: #fff; display: flex; flex-direction: column;
          justify-content: center; align-items: center; z-index: 1000;
          font-family: "SF Pro Display", "Helvetica Neue", system-ui, sans-serif;
          opacity: 0; transition: opacity 0.8s ease;
        `;
        modal.innerHTML = `
          <div style="font-size: 8rem; font-weight: 100; margin-bottom: 1rem; letter-spacing: -0.05em;">∩</div>
          <h1 style="font-size: 2.5rem; font-weight: 200; margin-bottom: 1.5rem; letter-spacing: 0.3em; text-transform: uppercase;">Level 10</h1>
          <p style="font-size: 1rem; margin-bottom: 3rem; opacity: 0.6; font-weight: 300;">You unlocked the bridge. Follow for more.</p>
          <div style="display: flex; gap: 1.5rem;">
            <a href="https://x.com/br1dge_dev" target="_blank" style="color: #fff; text-decoration: none; font-size: 1rem; padding: 0.8rem 2rem; border: 1px solid rgba(255,255,255,0.3); transition: all 0.3s; letter-spacing: 0.1em;">X / TWITTER</a>
            <a href="https://warpcast.com/br1dge" target="_blank" style="color: #fff; text-decoration: none; font-size: 1rem; padding: 0.8rem 2rem; border: 1px solid rgba(255,255,255,0.3); transition: all 0.3s; letter-spacing: 0.1em;">FARCASTER</a>
          </div>
          <p style="position: absolute; bottom: 2rem; font-size: 0.75rem; opacity: 0.3;">br1dge.xyz</p>
        `;
        
        // Hover-Effekte für Links
        modal.querySelectorAll('a').forEach(link => {
          link.addEventListener('mouseenter', () => {
            link.style.background = 'rgba(255,255,255,0.1)';
            link.style.borderColor = '#fff';
          });
          link.addEventListener('mouseleave', () => {
            link.style.background = 'transparent';
            link.style.borderColor = 'rgba(255,255,255,0.3)';
          });
        });
        
        document.body.appendChild(modal);
        
        // Fade in
        requestAnimationFrame(() => {
          modal.style.opacity = '1';
        });
      }
      
      // 2026 Minimal Background - Clean, Dark, Sophisticated
      function drawGrid() {
        const time = Date.now() / 1000;
        
        // Pure black with subtle depth
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, W, H);
        
        // Sehr subtiler radialer Gradient - kaum sichtbar
        const subtleGradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
        subtleGradient.addColorStop(0, 'rgba(20, 20, 25, 0.5)');
        subtleGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = subtleGradient;
        ctx.fillRect(0, 0, W, H);
        
        // Minimales Dot-Grid statt Linien (moderner)
        const dotSpacing = 80;
        const dotSize = 1;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
        
        for (let x = dotSpacing; x < W; x += dotSpacing) {
          for (let y = dotSpacing; y < H; y += dotSpacing) {
            ctx.beginPath();
            ctx.arc(x, y, dotSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Subtile vertikale Linien (sehr dünn, sehr transparent)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.015)';
        ctx.lineWidth = 1;
        for (let x = 0; x < W; x += 200) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
          ctx.stroke();
        }
      }
      
      // Draw the logo - CLEAN, MINIMAL, CENTERED
      function drawLogo() {
        const time = Date.now() / 1000;
        const baseLogoSize = Math.min(W, H) * 0.32; // Größer!
        const logoSize = baseLogoSize * logoBaseScale;
        
        logoScale += (logoTargetScale - logoScale) * 0.12;
        logoGlow *= 0.9;
        
        const exactCenterX = W / 2;
        const exactCenterY = H / 2;
        
        ctx.save();
        ctx.translate(exactCenterX, exactCenterY);
        ctx.scale(logoScale, logoScale);
        
        ctx.font = `200 ${logoSize}px "SF Pro Display", "Helvetica Neue", system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Chromatic Aberration - VIEL STÄRKER mit Level
        if (upgradeLevel > 0) {
          const offset = 4 + upgradeLevel * 2.5; // Deutlich mehr Offset
          const aberrationPulse = 1 + Math.sin(time * 3) * 0.15; // Pulsierend
          const effectiveOffset = offset * aberrationPulse;
          
          // Mehrere Layer für stärkeren Effekt
          ctx.globalAlpha = 0.15 + upgradeLevel * 0.04;
          ctx.fillStyle = '#ff0066';
          ctx.fillText('∩', -effectiveOffset * 1.5, -effectiveOffset * 0.3);
          ctx.fillStyle = '#00ffff';
          ctx.fillText('∩', effectiveOffset * 1.5, effectiveOffset * 0.3);
          
          // Zweiter Layer - näher
          ctx.globalAlpha = 0.4 + upgradeLevel * 0.05;
          ctx.fillStyle = '#ff0066';
          ctx.fillText('∩', -effectiveOffset, 0);
          ctx.fillStyle = '#00ffff';
          ctx.fillText('∩', effectiveOffset, 0);
          
          // Grüner Kanal bei höheren Levels
          if (upgradeLevel >= 3) {
            ctx.globalAlpha = 0.2 + (upgradeLevel - 3) * 0.05;
            ctx.fillStyle = '#00ff66';
            ctx.fillText('∩', 0, -effectiveOffset * 0.5);
          }
          
          ctx.globalAlpha = 1;
        }
        
        // Haupt-Symbol - weiß
        ctx.fillStyle = '#ffffff';
        ctx.fillText('∩', 0, 0);
        
        ctx.restore();
        
        // Level Anzeige rechts unten
        ctx.font = '12px monospace';
        ctx.textAlign = 'right';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fillText(`lvl:${upgradeLevel}`, W - 20, H - 20);
        
        // Expanding Rings bei Entladung - mit Farbe
        for (let i = logoOutlines.length - 1; i >= 0; i--) {
          const outline = logoOutlines[i];
          outline.alpha *= 0.96;
          outline.radius = (outline.radius || 10) + 5;
          
          if (outline.alpha < 0.01) {
            logoOutlines.splice(i, 1);
            continue;
          }
          
          ctx.beginPath();
          ctx.arc(exactCenterX, exactCenterY, outline.radius * logoScale, 0, Math.PI * 2);
          ctx.strokeStyle = outline.hue !== undefined
            ? `hsla(${outline.hue}, 100%, 70%, ${outline.alpha})`
            : `rgba(255, 255, 255, ${outline.alpha})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
      
      // Draw particles - CLEAN
      function drawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.life -= 0.02;
          
          if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
          }
          
          ctx.beginPath();
          ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = p.hue 
            ? `hsla(${p.hue}, 100%, 70%, ${p.life})`
            : `rgba(255, 255, 255, ${p.life})`;
          ctx.fill();
        }
      }
      
      // Ambient floating particles - CURSOR Gravitation
      function drawAmbientParticles() {
        const time = Date.now() / 1000;
        
        // VIELE Partikel spawnen - von allen Seiten UND im Bildschirm
        const maxParticles = 150;
        const spawnRate = 0.4; // Höhere Spawn-Rate
        
        if (ambientParticles.length < maxParticles && Math.random() < spawnRate) {
          let x, y, vx, vy;
          
          // 40% von Rändern, 60% im Bildschirm - bessere Verteilung
          if (Math.random() < 0.4) {
            // Von Rändern - mit Drift zur Mitte
            const edge = Math.floor(Math.random() * 4);
            const centerX = W / 2, centerY = H / 2;
            switch(edge) {
              case 0: x = Math.random() * W; y = -10; break;
              case 1: x = W + 10; y = Math.random() * H; break;
              case 2: x = Math.random() * W; y = H + 10; break;
              default: x = -10; y = Math.random() * H;
            }
            // Drift zur Mitte
            const dx = centerX - x, dy = centerY - y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            vx = (dx / dist) * (0.8 + Math.random() * 0.6);
            vy = (dy / dist) * (0.8 + Math.random() * 0.6);
          } else {
            // Im Bildschirm - mittlerer Bereich bevorzugt
            x = W * 0.2 + Math.random() * W * 0.6;
            y = H * 0.2 + Math.random() * H * 0.6;
            vx = (Math.random() - 0.5) * 0.5;
            vy = (Math.random() - 0.5) * 0.5;
          }
          
          ambientParticles.push({
            x, y, vx, vy,
            size: 1.5 + Math.random() * 3,
            alpha: 0.5 + Math.random() * 0.4,
            twinkle: Math.random() * Math.PI * 2,
            absorbed: false
          });
        }
        
        // Draw and update particles
        for (let i = ambientParticles.length - 1; i >= 0; i--) {
          const p = ambientParticles[i];
          
          // CURSOR Gravitation - STÄRKER
          const dx = cursorX - p.x;
          const dy = cursorY - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const gravityRadius = 280; // Größere Reichweite
          
          if (dist < gravityRadius && dist > 8) {
            // Gravitation: quadratisch stärker je näher
            const normalizedDist = dist / gravityRadius;
            const pullStrength = Math.pow(1 - normalizedDist, 2) * 0.15;
            p.vx += (dx / dist) * pullStrength;
            p.vy += (dy / dist) * pullStrength;
            
            // Partikel beschleunigt sichtbar zum Cursor
            if (dist < 100) {
              p.vx += (dx / dist) * 0.08;
              p.vy += (dy / dist) * 0.08;
            }
          }
          
          // Partikel wird vom Cursor absorbiert - nur wenn nicht voll
          if (dist < 20 && !p.absorbed && cursorEnergy < MAX_ENERGY) {
            p.absorbed = true;
            cursorEnergy = Math.min(MAX_ENERGY, cursorEnergy + 0.008);
            p.alpha *= 0.2;
            
            // Wenn gerade voll geworden UND noch Catches übrig, Red Particle spawnen
            if (cursorEnergy >= MAX_ENERGY && !redParticle.active && redParticleCatches < 2) {
              redParticleSpawnTime = Date.now() + 1500; // 1.5 Sekunden warten
              redParticleActive = true;
            }
          }
          
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.985;
          p.vy *= 0.985;
          p.twinkle += 0.05;
          
          if (p.absorbed) {
            p.alpha *= 0.8;
          }
          
          // Remove
          if (p.x < -50 || p.x > W + 50 || p.y < -50 || p.y > H + 50 || p.alpha < 0.01) {
            ambientParticles.splice(i, 1);
            continue;
          }
          
          const twinkleAlpha = p.alpha * (0.7 + Math.sin(p.twinkle) * 0.3);
          
          // Cleaner look - nur weiß mit Intensitätsvariation
          let alpha = twinkleAlpha;
          if (dist < gravityRadius && !p.absorbed) {
            // Heller wenn nah am Cursor
            alpha = twinkleAlpha * (1 + (1 - dist / gravityRadius) * 0.5);
          }
          
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * (p.absorbed ? 0.3 : 1), 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, alpha)})`;
          ctx.fill();
        }
      }
      

      
      // Red Particle - spawnt nach voller Ladung, schwierige Flugbahn
      function drawRedParticle() {
        const time = Date.now() / 1000;
        
        // Spawn nach Timer
        if (redParticleActive && !redParticle.active && Date.now() > redParticleSpawnTime) {
          const edge = Math.floor(Math.random() * 4);
          const speed = 6 + Math.random() * 4; // Schneller
          switch(edge) {
            case 0: redParticle.x = Math.random() * W; redParticle.y = -10; break;
            case 1: redParticle.x = W + 10; redParticle.y = Math.random() * H; break;
            case 2: redParticle.x = Math.random() * W; redParticle.y = H + 10; break;
            default: redParticle.x = -10; redParticle.y = Math.random() * H;
          }
          // Zufällige Richtung - nicht direkt durch Mitte
          const angle = Math.random() * Math.PI * 2;
          redParticle.vx = Math.cos(angle) * speed;
          redParticle.vy = Math.sin(angle) * speed;
          redParticle.active = true;
          redParticle.phase = Math.random() * Math.PI * 2;
        }
        
        if (!redParticle.active) return;
        
        // Kurvige Flugbahn - Sinuswellen
        redParticle.phase = (redParticle.phase || 0) + 0.15;
        const curve = Math.sin(redParticle.phase) * 3;
        const perpX = -redParticle.vy / Math.sqrt(redParticle.vx*redParticle.vx + redParticle.vy*redParticle.vy);
        const perpY = redParticle.vx / Math.sqrt(redParticle.vx*redParticle.vx + redParticle.vy*redParticle.vy);
        
        redParticle.x += redParticle.vx + perpX * curve;
        redParticle.y += redParticle.vy + perpY * curve;
        
        // Check capture
        const dx = cursorX - redParticle.x;
        const dy = cursorY - redParticle.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 30) {
          // CAPTURED! Aktiviere Inversion
          isInverted = true;
          canvas.style.filter = 'invert(1)'; // GESAMTE APP INVERTIEREN!
          redParticle.active = false;
          redParticleCatches++;
          
          // Roter Partikel-Burst - MASSIV
          for (let i = 0; i < 60; i++) {
            const angle = (i / 60) * Math.PI * 2;
            const speed = 8 + Math.random() * 8;
            particles.push({
              x: redParticle.x,
              y: redParticle.y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 1.2,
              hue: 0
            });
          }
          
          // Mehrere Shockwaves
          for (let s = 0; s < 4; s++) {
            setTimeout(() => {
              ripples.push({
                x: redParticle.x,
                y: redParticle.y,
                size: 10 + s * 30,
                alpha: 1,
                hue: 0
              });
            }, s * 50);
          }
          
          // Wenn noch Catches übrig, neuer Red Particle spawnt
          if (redParticleCatches < 2 && cursorEnergy >= MAX_ENERGY) {
            redParticleSpawnTime = Date.now() + 1000;
            redParticleActive = true;
          }
        }
        
        // Off screen - neuer Versuch wenn noch Catches übrig
        if (redParticle.x < -50 || redParticle.x > W + 50 || redParticle.y < -50 || redParticle.y > H + 50) {
          redParticle.active = false;
          if (redParticleCatches < 2 && cursorEnergy >= MAX_ENERGY) {
            redParticleSpawnTime = Date.now() + 500;
            redParticleActive = true;
          }
        }
        
        // Draw - helles Blutrot, pulsierend
        const pulse = 1 + Math.sin(time * 10) * 0.2;
        ctx.beginPath();
        ctx.arc(redParticle.x, redParticle.y, 5 * pulse, 0, Math.PI * 2);
        ctx.fillStyle = '#ff2222';
        ctx.fill();
        
        // Trail
        ctx.beginPath();
        ctx.moveTo(redParticle.x, redParticle.y);
        ctx.lineTo(redParticle.x - redParticle.vx * 2, redParticle.y - redParticle.vy * 2);
        ctx.strokeStyle = 'rgba(255, 34, 34, 0.6)';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      
      // Minimal overlay - nur subtile Vignette
      function drawScanlines() {
        // Elegante Vignette
        const vignetteGradient = ctx.createRadialGradient(
          W/2, H/2, Math.min(W, H) * 0.3,
          W/2, H/2, Math.max(W, H) * 0.8
        );
        vignetteGradient.addColorStop(0, 'transparent');
        vignetteGradient.addColorStop(0.7, 'transparent');
        vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
        ctx.fillStyle = vignetteGradient;
        ctx.fillRect(0, 0, W, H);
      }
      
      // Draw ripples - mit optionaler Farbe
      function drawRipples() {
        for (let i = ripples.length - 1; i >= 0; i--) {
          const r = ripples[i];
          r.size += 12;
          r.alpha -= 0.02;
          
          if (r.alpha <= 0) {
            ripples.splice(i, 1);
            continue;
          }
          
          ctx.beginPath();
          ctx.arc(r.x, r.y, r.size, 0, Math.PI * 2);
          ctx.strokeStyle = r.hue !== undefined 
            ? `hsla(${r.hue}, 100%, 70%, ${r.alpha})`
            : `rgba(255, 255, 255, ${r.alpha})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
      
      // 2026 Cursor - CLEAN, SHARP, SNAPPY
      function drawCursor() {
        const time = Date.now() / 1000;
        
        const logoX = W / 2;
        const logoY = H / 2;
        const dxToLogo = mouseX - logoX;
        const dyToLogo = mouseY - logoY;
        const distToLogo = Math.sqrt(dxToLogo * dxToLogo + dyToLogo * dyToLogo);
        
        // ANZIEHUNG zum Logo wenn geladen - Cursor wird eingefangen
        let pullX = 0, pullY = 0;
        const captureRadius = 180;
        if (distToLogo < captureRadius && cursorEnergy >= ENERGY_THRESHOLD) {
          const proximity = 1 - distToLogo / captureRadius;
          const pullStrength = cursorEnergy * proximity * 0.6;
          if (distToLogo > 1) {
            pullX = -(dxToLogo / distToLogo) * pullStrength * distToLogo * 0.3;
            pullY = -(dyToLogo / distToLogo) * pullStrength * distToLogo * 0.3;
          }
        }
        
        const targetX = mouseX + pullX;
        const targetY = mouseY + pullY;
        // SNAPPY - schnellere Reaktion
        cursorX += (targetX - cursorX) * 0.25;
        cursorY += (targetY - cursorY) * 0.25;
        
        // Größe
        const baseSize = 5;
        const energySize = cursorEnergy * 18;
        const cursorSize = baseSize + energySize;
        
        ctx.save();
        ctx.translate(cursorX, cursorY);
        
        // === POWER METER - Solid Rings, keine Transparenz ===
        const totalLayers = 5;
        const energyPerLayer = MAX_ENERGY / totalLayers;
        
        for (let layer = 0; layer < totalLayers; layer++) {
          const layerStart = layer * energyPerLayer;
          const layerProgress = Math.max(0, Math.min(1, (cursorEnergy - layerStart) / energyPerLayer));
          if (layerProgress <= 0) continue;
          
          const ringRadius = cursorSize + 5 + layer * 5;
          const ringWidth = 4;
          
          ctx.beginPath();
          ctx.arc(0, 0, ringRadius, -Math.PI/2, -Math.PI/2 + layerProgress * Math.PI * 2);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = ringWidth;
          ctx.lineCap = 'butt';
          ctx.stroke();
        }
        
        // Core - clean, solid
        ctx.beginPath();
        ctx.arc(0, 0, cursorSize, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        
        ctx.restore();
      }
      
      // Main render
      function render() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);
        
        drawGrid();
        drawAmbientParticles();
        drawRedParticle();
        drawParticles();
        drawLogo();
        drawRipples();
        drawCursor();
        drawScanlines();
        
        requestAnimationFrame(render);
      }
      
      // Events
      window.addEventListener('resize', resize);
      
      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });
      
      // Click auf Logo = ENERGIE EXPLOSION (nur wenn Threshold erreicht)
      document.addEventListener('click', (e) => {
        const dist = distFromLogo(e.clientX, e.clientY);
        const logoRadius = Math.min(W, H) * 0.22 * logoBaseScale;
        const exactCenterX = W / 2;
        const exactCenterY = H / 2;
        
        // Ripple immer
        ripples.push({
          x: e.clientX,
          y: e.clientY,
          size: 5,
          alpha: 0.5,
          hue: 0
        });
        
        // Nur wenn auf Logo geklickt UND Threshold erreicht
        if (dist < logoRadius && cursorEnergy >= ENERGY_THRESHOLD && upgradeLevel < 10) {
          // Bei Inversion: 3 Levels auf einmal
          const levelsToAdd = isInverted ? 3 : 1;
          upgradeLevel = Math.min(10, upgradeLevel + levelsToAdd);
          logoBaseScale += 0.18 * levelsToAdd; // NOCH STÄRKER - sehr sichtbar
          
          // Inversion zurücksetzen nach Discharge
          if (isInverted) {
            isInverted = false;
            canvas.style.filter = '';
          }
          
          const intensity = cursorEnergy;
          const releaseHue = (upgradeLevel * 40) % 360;
          
          // Mehr Ringe bei höheren Levels
          const ringCount = 5 + upgradeLevel * 2;
          for (let o = 0; o < ringCount; o++) {
            setTimeout(() => {
              logoOutlines.push({
                alpha: 1,
                radius: 10 + o * 6,
                hue: (releaseHue + o * 15) % 360
              });
            }, o * 20);
          }
          
          // Scale punch - stärker bei höheren Levels
          logoTargetScale = 1.2 + upgradeLevel * 0.05;
          setTimeout(() => { logoTargetScale = 1; }, 150);
          
          // Level 10 erreicht - Modal zeigen
          if (upgradeLevel >= 10) {
            setTimeout(() => {
              showModal();
            }, 500);
          }
          
          // DRUCKWELLE - alle ambient particles wegstoßen
          for (let ap of ambientParticles) {
            const apDx = ap.x - exactCenterX;
            const apDy = ap.y - exactCenterY;
            const apDist = Math.sqrt(apDx * apDx + apDy * apDy);
            if (apDist > 0 && apDist < 400) {
              const pushStrength = (1 - apDist / 400) * 15 * intensity;
              ap.vx += (apDx / apDist) * pushStrength;
              ap.vy += (apDy / apDist) * pushStrength;
            }
          }
          
          // Mehr farbige Partikel
          const particleCount = Math.floor(50 + intensity * 80 + upgradeLevel * 12);
          for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const speed = 6 + Math.random() * 12 * intensity;
            particles.push({
              x: exactCenterX,
              y: exactCenterY,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 1,
              hue: (releaseHue + Math.random() * 60) % 360
            });
          }
          
          // Mehrere Shockwaves
          for (let s = 0; s < 3; s++) {
            setTimeout(() => {
              ripples.push({
                x: exactCenterX,
                y: exactCenterY,
                size: 10 + s * 20,
                alpha: 1,
                hue: (releaseHue + s * 30) % 360
              });
            }, s * 40);
          }
          
          cursorEnergy = 0;
          redParticleActive = false;
          redParticleCatches = 0; // Reset für nächste Ladung
          redParticle.active = false;
        }
      });
      
      // Touch support
      document.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        mouseX = touch.clientX;
        mouseY = touch.clientY;
      });
      
      document.addEventListener('touchmove', (e) => {
        const touch = e.touches[0];
        mouseX = touch.clientX;
        mouseY = touch.clientY;
        e.preventDefault();
      }, { passive: false });
      
      // Touch tap = ENERGIE EXPLOSION (nur wenn Threshold erreicht)
      document.addEventListener('touchend', (e) => {
        if (e.changedTouches.length > 0) {
          const touch = e.changedTouches[0];
          const dist = distFromLogo(touch.clientX, touch.clientY);
          const logoRadius = Math.min(W, H) * 0.22 * logoBaseScale;
          const exactCenterX = W / 2;
          const exactCenterY = H / 2;
          
          ripples.push({
            x: touch.clientX,
            y: touch.clientY,
            size: 5,
            alpha: 0.5,
            hue: 0
          });
          
          if (dist < logoRadius && cursorEnergy >= ENERGY_THRESHOLD && upgradeLevel < 10) {
            const levelsToAdd = isInverted ? 3 : 1;
            upgradeLevel = Math.min(10, upgradeLevel + levelsToAdd);
            logoBaseScale += 0.18 * levelsToAdd; // Stärker wie Desktop
            
            // Inversion zurücksetzen nach Discharge
            if (isInverted) {
              isInverted = false;
              canvas.style.filter = '';
            }
            
            const intensity = cursorEnergy;
            const releaseHue = (upgradeLevel * 50) % 360;
            
            const ringCount = 5 + upgradeLevel * 2;
            for (let o = 0; o < ringCount; o++) {
              setTimeout(() => {
                logoOutlines.push({
                  alpha: 1,
                  radius: 15 + o * 8,
                  hue: (releaseHue + o * 20) % 360
                });
              }, o * 25);
            }
            
            logoTargetScale = 1.25;
            setTimeout(() => { logoTargetScale = 1; }, 120);
            
            // Level 10 Modal
            if (upgradeLevel >= 10) {
              setTimeout(() => {
                showModal();
              }, 500);
            }
            
            // Druckwelle
            for (let ap of ambientParticles) {
              const apDx = ap.x - exactCenterX;
              const apDy = ap.y - exactCenterY;
              const apDist = Math.sqrt(apDx * apDx + apDy * apDy);
              if (apDist > 0 && apDist < 400) {
                const pushStrength = (1 - apDist / 400) * 15 * intensity;
                ap.vx += (apDx / apDist) * pushStrength;
                ap.vy += (apDy / apDist) * pushStrength;
              }
            }
            
            const particleCount = Math.floor(50 + intensity * 80 + upgradeLevel * 12);
            for (let i = 0; i < particleCount; i++) {
              const angle = (i / particleCount) * Math.PI * 2;
              const speed = 6 + Math.random() * 12 * intensity;
              particles.push({
                x: exactCenterX,
                y: exactCenterY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1,
                hue: (releaseHue + Math.random() * 60) % 360
              });
            }
            
            for (let s = 0; s < 3; s++) {
              setTimeout(() => {
                ripples.push({
                  x: exactCenterX,
                  y: exactCenterY,
                  size: 10 + s * 20,
                  alpha: 1,
                  hue: (releaseHue + s * 30) % 360
                });
              }, s * 40);
            }
            
            cursorEnergy = 0;
            redParticleActive = false;
            redParticleCatches = 0;
            redParticle.active = false;
          }
        }
      });
      
      // Init
      resize();
      render();
    </script>
  </body>
</html>
